// Auto-generated by multjs C++ transpiler
#pragma once

#include <cstdint>
#include <string>
#include <vector>
#include <optional>
#include <variant>

#include "mjs/cpp_gen/mjs_runtime.h"

namespace mjs_generated {

    struct Struct_0 : public mjs::generated::JSObject {
        std::string name;
        int64_t level;
        int64_t health;

        // 构造函数，需要Context参数用于基类初始化
        Struct_0(mjs::Context* context
, const std::string& name_, const int64_t& level_, const int64_t& health_) : mjs::generated::JSObject(context) {
            this->name = name_;
            this->level = level_;
            this->health = health_;
        }

        // 重载 [] 运算符，支持静态属性和动态属性访问
        template<typename T>
        auto& GetProperty(mjs::Context* context, const T& key) {
            if constexpr (std::is_same_v<T, std::string>) {
                if (key == "name") { return name; }
                else if (key == "level") { return level; }
                else if (key == "health") { return health; }
                else { return mjs::generated::GetProperty(context, key); }
            } else {
                return mjs::generated::GetProperty(context, key);
            }
        }

        template<typename T>
        auto GetProperty(mjs::Context* context, const T& key) const {
            if constexpr (std::is_same_v<T, std::string>) {
                if (key == "name") { return name; }
                else if (key == "level") { return level; }
                else if (key == "health") { return health; }
                else { return mjs::generated::GetProperty(context, key); }
            } else {
                return mjs::generated::GetProperty(context, key);
            }
        }
    };


auto calculateDamage(auto base, auto multiplier, auto critical) {
    auto damage = (base * multiplier);
    if (critical) {
        damage = (damage * 2);
    }
    return damage;
}

mjs::Value player = mjs::Value(new Struct_0(context, "Ash", 25, 100));
int64_t attackPower = 50;
int64_t defense = 20;
bool isCritical = true;
auto finalDamage = calculateDamage(attackPower, 1.5, isCritical);
auto remainingHealth = (player.object<Struct_0>()->health - finalDamage);
std::vector<std::string> items = {"Potion", "Antidote", "Paralyze Heal"};
for (int64_t i = 0; (i < items.size()); i++) {
    auto itemName = items[i];
}
if ((remainingHealth <= 0)) {
    player.object<Struct_0>()->health = 0;
}
else {
    player.object<Struct_0>()->health = remainingHealth;
}
} // namespace mjs_generated
