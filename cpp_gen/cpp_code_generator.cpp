/**
 * @file cpp_code_generator.cpp
 * @brief CppCodeGenerator实现
 */

#include "./cpp_code_generator.h"
#include "src/compiler/parser.h"
#include "src/compiler/expression.h"
#include "src/compiler/statement.h"
#include "mjs/token.h"
#include "src/compiler/expression_impl/integer_literal.h"
#include "src/compiler/expression_impl/float_literal.h"
#include "src/compiler/expression_impl/string_literal.h"
#include "src/compiler/expression_impl/boolean_literal.h"
#include "src/compiler/expression_impl/identifier.h"
#include "src/compiler/expression_impl/binary_expression.h"
#include "src/compiler/expression_impl/assignment_expression.h"
#include "src/compiler/expression_impl/call_expression.h"
#include "src/compiler/expression_impl/member_expression.h"
#include "src/compiler/expression_impl/array_expression.h"
#include "src/compiler/expression_impl/object_expression.h"
#include "src/compiler/expression_impl/function_expression.h"
#include "src/compiler/expression_impl/unary_expression.h"
#include "src/compiler/statement_impl/expression_statement.h"
#include "src/compiler/statement_impl/block_statement.h"
#include "src/compiler/statement_impl/variable_declaration.h"
#include "src/compiler/statement_impl/return_statement.h"
#include "src/compiler/statement_impl/if_statement.h"
#include "src/compiler/statement_impl/while_statement.h"
#include "src/compiler/statement_impl/for_statement.h"
#include <sstream>
#include <stdexcept>
#include <cstdio>

namespace mjs {
namespace compiler {
namespace cpp_gen {

CppCodeGenerator::CppCodeGenerator(const CppCodeGeneratorConfig& config)
    : config_(config), emitter_(config.indent_size) {}

std::string CppCodeGenerator::Generate(const Parser& parser) {
    // 清空之前的生成结果
    emitter_.Clear();
    type_engine_.Clear();

    // 生成文件头部
    GenerateHeader();
    emitter_.EmitBlankLine();

    // 生成命名空间
    GenerateNamespaceStart();
    emitter_.EmitBlankLine();

    // 获取AST并生成代码
    const auto& statements = parser.statements();

    // 先进行类型推断
    if (config_.enable_type_inference) {
        for (const auto& stmt : statements) {
            type_engine_.InferStatementType(stmt.get());
        }
    }

    // 生成对象结构体定义（在类型推断之后）
    GenerateStructDefinitions();
    emitter_.EmitBlankLine();

    // 第一遍：生成函数声明（不包装在初始化函数中）
    std::ostringstream temp_stream;
    if (config_.wrap_global_code) {
        for (const auto& stmt : statements) {
            // 检查是否是函数声明
            if (auto* expr_stmt = dynamic_cast<const ExpressionStatement*>(stmt.get())) {
                if (dynamic_cast<const FunctionExpression*>(expr_stmt->expression().get())) {
                    // 这是函数声明，直接生成
                    GenerateStatement(stmt.get(), temp_stream);
                    std::string func_str = temp_stream.str();

                    // 对每一行添加缩进
                    std::istringstream lines(func_str);
                    std::string line;
                    while (std::getline(lines, line)) {
                        if (!line.empty()) {
                            emitter_.EmitLine(line);
                        }
                    }

                    temp_stream.str("");
                    emitter_.EmitBlankLine();
                }
            }
        }
    }

    // 如果需要包装全局代码，则生成初始化函数
    if (config_.wrap_global_code) {
        GenerateInitFunctionStart();
    }

    // 第二遍：生成非函数声明的语句
    for (const auto& stmt : statements) {
        // 如果启用了包装，跳过函数声明（它们已经在上面生成过了）
        if (config_.wrap_global_code) {
            if (auto* expr_stmt = dynamic_cast<const ExpressionStatement*>(stmt.get())) {
                if (dynamic_cast<const FunctionExpression*>(expr_stmt->expression().get())) {
                    continue; // 跳过函数声明
                }
            }
        }

        // 对于包装在初始化函数中的语句，直接使用 emitter 输出以应用缩进
        GenerateStatement(stmt.get(), temp_stream);
        std::string stmt_str = temp_stream.str();

        // 如果启用了包装，需要对每一行添加缩进
        if (config_.wrap_global_code && !stmt_str.empty()) {
            std::istringstream lines(stmt_str);
            std::string line;
            while (std::getline(lines, line)) {
                if (!line.empty()) {
                    emitter_.EmitLine(line);
                }
            }
        } else {
            emitter_.EmitRaw(stmt_str);
        }

        temp_stream.str("");
        if (!stmt_str.empty() && stmt_str.back() != '\n') {
            emitter_.EmitBlankLine();
        }
    }

    // 如果需要包装全局代码，则结束初始化函数
    if (config_.wrap_global_code) {
        GenerateInitFunctionEnd();
        emitter_.EmitBlankLine();
    }

    // 生成命名空间结束
    GenerateNamespaceEnd();

    return emitter_.ToString();
}

void CppCodeGenerator::GenerateHeader() {
    emitter_.EmitLine("// Auto-generated by multjs C++ transpiler");
    emitter_.EmitLine("#pragma once");
    emitter_.EmitBlankLine();
    emitter_.EmitLine("#include <cstdint>");
    emitter_.EmitLine("#include <string>");
    emitter_.EmitLine("#include <vector>");
    emitter_.EmitLine("#include <optional>");
    emitter_.EmitLine("#include <variant>");
    emitter_.EmitBlankLine();
    emitter_.EmitLine("#include \"mjs/cpp_gen/mjs_runtime.h\"");
}

void CppCodeGenerator::GenerateNamespaceStart() {
    emitter_.EmitLine("namespace " + config_.namespace_name + " {");
    emitter_.Indent();
}

void CppCodeGenerator::GenerateNamespaceEnd() {
    emitter_.Dedent();
    emitter_.EmitLine("} // namespace " + config_.namespace_name);
}

void CppCodeGenerator::GenerateStructDefinitions() {
    // 获取所有推断出的对象类型
    const auto& object_types = type_engine_.GetObjectTypes();

    // 为每个对象类型生成结构体定义
    for (const auto& object_type : object_types) {
        if (!object_type->IsObject()) {
            continue;
        }

        const std::string& struct_name = object_type->GetStructName();
        const auto& properties = object_type->GetObjectProperties();

        // 生成结构体定义，继承自 mjs::generated::JSObject
        emitter_.EmitLine("struct " + struct_name + " : public mjs::generated::JSObject {");
        emitter_.Indent();

        // 生成成员变量
        for (const auto& prop : properties) {
            std::string prop_type_str = prop.type->ToString();
            emitter_.EmitLine(prop_type_str + " " + prop.name + ";");
        }

        emitter_.EmitBlankLine();

        // 生成构造函数
        emitter_.EmitLine("// 构造函数，需要Context参数用于基类初始化");
        emitter_.EmitLine(struct_name + "(mjs::Context* context");
        if (!properties.empty()) {
            emitter_.EmitRaw(", ");
        }

        for (size_t i = 0; i < properties.size(); ++i) {
            const auto& prop = properties[i];
            std::string prop_type_str = prop.type->ToString();
            emitter_.EmitRaw("const " + prop_type_str + "& " + prop.name + "_");

            if (i < properties.size() - 1) {
                emitter_.EmitRaw(", ");
            }
        }

        emitter_.EmitLine(") : mjs::generated::JSObject(context) {");

        emitter_.Indent();
        for (const auto& prop : properties) {
            emitter_.EmitLine("this->" + prop.name + " = " + prop.name + "_;");
        }

        emitter_.Dedent();
        emitter_.EmitLine("}");
        emitter_.EmitBlankLine();

        // 生成 GetProperty，支持编译期已知的属性访问
        emitter_.EmitLine("template<typename T>");
        emitter_.EmitLine("auto& GetProperty(mjs::Context* context, const T& key) {");
        emitter_.Indent();
        emitter_.EmitLine("if constexpr (std::is_same_v<T, std::string>) {");
        emitter_.Indent();

        // 对于字符串键，检查是否是已知属性
        bool first_property = true;
        for (const auto& prop : properties) {
            if (first_property) {
                emitter_.EmitLine("if (key == \"" + prop.name + "\") { return " + prop.name + "; }");
                first_property = false;
            } else {
                emitter_.EmitLine("else if (key == \"" + prop.name + "\") { return " + prop.name + "; }");
            }
        }
        emitter_.EmitLine("else { return JSObject::GetProperty(context, key); }");
        emitter_.Dedent();
        emitter_.EmitLine("} else {");
        emitter_.Indent();
        emitter_.EmitLine("return JSObject::GetProperty(context, key);");
        emitter_.Dedent();
        emitter_.EmitLine("}");
        emitter_.Dedent();
        emitter_.EmitLine("}");
        emitter_.EmitBlankLine();

        // 生成 const 版本
        emitter_.EmitLine("template<typename T>");
        emitter_.EmitLine("auto GetProperty(mjs::Context* context, const T& key) const {");
        emitter_.Indent();
        emitter_.EmitLine("if constexpr (std::is_same_v<T, std::string>) {");
        emitter_.Indent();

        first_property = true;
        for (const auto& prop : properties) {
            if (first_property) {
                emitter_.EmitLine("if (key == \"" + prop.name + "\") { return " + prop.name + "; }");
                first_property = false;
            } else {
                emitter_.EmitLine("else if (key == \"" + prop.name + "\") { return " + prop.name + "; }");
            }
        }
        emitter_.EmitLine("else { return JSObject::GetProperty(context, key); }");
        emitter_.Dedent();
        emitter_.EmitLine("} else {");
        emitter_.Indent();
        emitter_.EmitLine("return JSObject::GetProperty(context, key);");
        emitter_.Dedent();
        emitter_.EmitLine("}");
        emitter_.Dedent();
        emitter_.EmitLine("}");
        
        emitter_.Dedent();
        emitter_.EmitLine("};");
        emitter_.EmitBlankLine();
    }
}

void CppCodeGenerator::GenerateInitFunctionStart() {
    // 初始化函数需要Context参数，用于对象创建
    emitter_.EmitLine("void " + config_.init_function_name + "(mjs::Context* context) {");
    emitter_.Indent();
}

void CppCodeGenerator::GenerateInitFunctionEnd() {
    emitter_.Dedent();
    emitter_.EmitLine("}");
}

void CppCodeGenerator::GenerateExpression(const Expression* expr, std::ostream& os) {
    if (!expr) {
        os << "/* null expression */";
        return;
    }

    // 字面量
    if (dynamic_cast<const IntegerLiteral*>(expr)) {
        GenerateIntegerLiteral(expr, os);
        return;
    }

    if (dynamic_cast<const FloatLiteral*>(expr)) {
        GenerateFloatLiteral(expr, os);
        return;
    }

    if (dynamic_cast<const StringLiteral*>(expr)) {
        GenerateStringLiteral(expr, os);
        return;
    }

    if (dynamic_cast<const BooleanLiteral*>(expr)) {
        GenerateBooleanLiteral(expr, os);
        return;
    }

    // 标识符
    if (auto* ident = dynamic_cast<const Identifier*>(expr)) {
        GenerateIdentifier(expr, os);
        return;
    }

    // 二元表达式
    if (dynamic_cast<const BinaryExpression*>(expr)) {
        GenerateBinaryExpression(expr, os);
        return;
    }

    // 函数调用
    if (dynamic_cast<const CallExpression*>(expr)) {
        GenerateCallExpression(expr, os);
        return;
    }

    // 成员访问
    if (dynamic_cast<const MemberExpression*>(expr)) {
        GenerateMemberExpression(expr, os);
        return;
    }

    // 赋值表达式
    if (dynamic_cast<const AssignmentExpression*>(expr)) {
        GenerateAssignmentExpression(expr, os);
        return;
    }

    // 一元表达式
    if (dynamic_cast<const UnaryExpression*>(expr)) {
        GenerateUnaryExpression(expr, os);
        return;
    }

    // 数组
    if (dynamic_cast<const ArrayExpression*>(expr)) {
        GenerateArrayExpression(expr, os);
        return;
    }

    // 对象
    if (dynamic_cast<const ObjectExpression*>(expr)) {
        GenerateObjectExpression(expr, os);
        return;
    }

    // 函数表达式
    if (auto* func = dynamic_cast<const FunctionExpression*>(expr)) {
        // 函数表达式暂时作为注释输出
        os << "/* function expression: " << (func->id().empty() ? "<anonymous>" : func->id()) << " */";
        return;
    }

    // 未支持的表达式类型
    os << "/* unsupported expression */";
}

void CppCodeGenerator::GenerateIntegerLiteral(const Expression* expr, std::ostream& os) {
    auto* lit = dynamic_cast<const IntegerLiteral*>(expr);
    if (lit) {
        os << lit->value();
    }
}

void CppCodeGenerator::GenerateFloatLiteral(const Expression* expr, std::ostream& os) {
    auto* lit = dynamic_cast<const FloatLiteral*>(expr);
    if (lit) {
        os << lit->value();
    }
}

void CppCodeGenerator::GenerateStringLiteral(const Expression* expr, std::ostream& os) {
    auto* lit = dynamic_cast<const StringLiteral*>(expr);
    if (!lit) {
        return;
    }

    os << "\"";

    // 转义特殊字符
    const std::string& str = lit->value();
    for (char c : str) {
        switch (c) {
            case '"':  os << "\\\""; break;
            case '\\': os << "\\\\"; break;
            case '\n': os << "\\n"; break;
            case '\r': os << "\\r"; break;
            case '\t': os << "\\t"; break;
            case '\0': os << "\\0"; break;
            default:
                // 其他可打印字符直接输出
                if (c >= 32 && c < 127) {
                    os << c;
                } else {
                    // 非打印字符使用八进制转义
                    char octal[5];
                    snprintf(octal, sizeof(octal), "\\%03o", static_cast<unsigned char>(c));
                    os << octal;
                }
                break;
        }
    }

    os << "\"";
}

void CppCodeGenerator::GenerateBooleanLiteral(const Expression* expr, std::ostream& os) {
    auto* lit = dynamic_cast<const BooleanLiteral*>(expr);
    if (lit) {
        os << (lit->value() ? "true" : "false");
    }
}

void CppCodeGenerator::GenerateIdentifier(const Expression* expr, std::ostream& os) {
    auto* ident = dynamic_cast<const Identifier*>(expr);
    if (ident) {
        os << name_mangler_.Mangle(ident->name());
    }
}

void CppCodeGenerator::GenerateBinaryExpression(const Expression* expr, std::ostream& os) {
    auto* binary = dynamic_cast<const BinaryExpression*>(expr);
    if (!binary) {
        return;
    }

    os << "(";
    GenerateExpression(binary->left().get(), os);

    // 转换运算符
    TokenType op = binary->op();
    switch (op) {
        case TokenType::kOpAdd: os << " + "; break;
        case TokenType::kOpSub: os << " - "; break;
        case TokenType::kOpMul: os << " * "; break;
        case TokenType::kOpDiv: os << " / "; break;
        case TokenType::kOpMod: os << " % "; break;
        case TokenType::kOpLt: os << " < "; break;
        case TokenType::kOpGt: os << " > "; break;
        case TokenType::kOpLe: os << " <= "; break;
        case TokenType::kOpGe: os << " >= "; break;
        case TokenType::kOpEq: os << " == "; break;
        case TokenType::kOpNe: os << " != "; break;
        case TokenType::kOpAnd: os << " && "; break;
        case TokenType::kOpOr: os << " || "; break;
        default: os << " /* unknown op */ "; break;
    }

    GenerateExpression(binary->right().get(), os);
    os << ")";
}

void CppCodeGenerator::GenerateUnaryExpression(const Expression* expr, std::ostream& os) {
    auto* unary = dynamic_cast<const UnaryExpression*>(expr);
    if (!unary) {
        return;
    }

    // 判断是前缀还是后缀运算符
    if (unary->is_prefix()) {
        // 前缀运算符：++, --, -, +, !, ~
        TokenType op = unary->op();
        switch (op) {
            case TokenType::kOpPrefixInc:
            case TokenType::kOpInc: os << "++"; break;
            case TokenType::kOpPrefixDec:
            case TokenType::kOpDec: os << "--"; break;
            case TokenType::kOpSub: os << "-"; break;
            case TokenType::kOpAdd: os << "+"; break;
            case TokenType::kOpNot: os << "!"; break;
            case TokenType::kOpBitNot: os << "~"; break;
            default: os << " /* unknown unary op */ "; break;
        }
        GenerateExpression(unary->argument().get(), os);
    } else {
        // 后缀运算符：++, --
        GenerateExpression(unary->argument().get(), os);
        TokenType op = unary->op();
        switch (op) {
            case TokenType::kOpSuffixInc:
            case TokenType::kOpInc: os << "++"; break;
            case TokenType::kOpSuffixDec:
            case TokenType::kOpDec: os << "--"; break;
            default: os << " /* unknown postfix op */ "; break;
        }
    }
}

void CppCodeGenerator::GenerateAssignmentExpression(const Expression* expr, std::ostream& os) {
    auto* assign = dynamic_cast<const AssignmentExpression*>(expr);
    if (!assign) {
        return;
    }

    // 生成左值（赋值目标）
    GenerateExpression(assign->left().get(), os);

    // 生成赋值运算符
    TokenType op = assign->op();
    switch (op) {
        case TokenType::kOpAssign: os << " = "; break;
        case TokenType::kOpAddAssign: os << " += "; break;
        case TokenType::kOpSubAssign: os << " -= "; break;
        case TokenType::kOpMulAssign: os << " *= "; break;
        case TokenType::kOpDivAssign: os << " /= "; break;
        case TokenType::kOpModAssign: os << " %= "; break;
        default: os << " /* unknown assign op */ "; break;
    }

    // 生成右值（赋值源）
    GenerateExpression(assign->right().get(), os);
}

void CppCodeGenerator::GenerateCallExpression(const Expression* expr, std::ostream& os) {
    auto* call = dynamic_cast<const CallExpression*>(expr);
    if (!call) {
        return;
    }

    GenerateExpression(call->callee().get(), os);
    os << "(";

    const auto& args = call->arguments();
    for (size_t i = 0; i < args.size(); ++i) {
        if (i > 0) os << ", ";
        GenerateExpression(args[i].get(), os);
    }

    os << ")";
}

void CppCodeGenerator::GenerateMemberExpression(const Expression* expr, std::ostream& os) {
    auto* member = dynamic_cast<const MemberExpression*>(expr);
    if (!member) {
        return;
    }

    // 推断对象类型
    auto object_type = config_.enable_type_inference
        ? type_engine_.InferExpressionType(member->object().get())
        : nullptr;

    if (member->computed()) {
        // 计算属性访问：使用高效的辅助函数 mjs::generated::GetComputedProperty
        // 生成：mjs::generated::GetComputedProperty(&obj.object<Type>(), context, key)

        // 检查属性类型以决定使用哪个重载
        bool is_int_index = false;
        if (auto* prop_expr = member->property().get()) {
            if (dynamic_cast<const IntegerLiteral*>(prop_expr)) {
                is_int_index = true;
            }
        }

        os << "mjs::generated::GetComputedProperty(&";

        // 生成对象表达式
        GenerateExpression(member->object().get(), os);

        if (object_type && object_type->IsArray()) {
            os << ".object<mjs::ArrayObject>(), context, ";
            GenerateExpression(member->property().get(), os);
        } else if (object_type && object_type->IsObject()) {
            os << ".object<mjs::generated::JSObject>(), context, ";
            GenerateExpression(member->property().get(), os);
        } else {
            // 动态类型
            os << ".object(), context, ";
            GenerateExpression(member->property().get(), os);
        }

        os << ")";
        return;
    }

    // 非计算属性访问
    // 生成对象表达式
    GenerateExpression(member->object().get(), os);

    // 静态属性访问
    if (object_type && object_type->IsObject()) {
        // 对象类型：使用 .object<Struct>()->property
        const std::string& struct_name = object_type->GetStructName();
        os << ".object<" << struct_name << ">().";

        if (auto* prop_ident = dynamic_cast<const Identifier*>(member->property().get())) {
            os << prop_ident->name();
        } else {
            GenerateExpression(member->property().get(), os);
        }
    } else if (object_type && object_type->IsArray()) {
        // 数组类型：使用 .object<mjs::ArrayObject>().property
        os << ".object<mjs::ArrayObject>().";

        if (auto* prop_ident = dynamic_cast<const Identifier*>(member->property().get())) {
            // 特殊处理数组的length属性
            if (prop_ident->name() == "length") {
                os << "length()";
            } else {
                os << prop_ident->name();
            }
        } else {
            GenerateExpression(member->property().get(), os);
        }
    } else {
        // 动态类型：使用 .object()->property
        os << ".object()->";

        if (auto* prop_ident = dynamic_cast<const Identifier*>(member->property().get())) {
            os << prop_ident->name();
        } else {
            GenerateExpression(member->property().get(), os);
        }
    }
}

void CppCodeGenerator::GenerateArrayExpression(const Expression* expr, std::ostream& os) {
    auto* array = dynamic_cast<const ArrayExpression*>(expr);
    if (!array) {
        return;
    }

    // 生成 mjs::Value(mjs::ArrayObject::New(context, {mjs::Value(...), ...}))
    os << "mjs::Value(mjs::ArrayObject::New(context, {";
    const auto& elements = array->elements();
    for (size_t i = 0; i < elements.size(); ++i) {
        if (i > 0) os << ", ";
        // 每个元素都需要用 mjs::Value() 包装
        os << "mjs::Value(";
        GenerateExpression(elements[i].get(), os);
        os << ")";
    }
    os << "}))";
}

void CppCodeGenerator::GenerateObjectExpression(const Expression* expr, std::ostream& os) {
    auto* object = dynamic_cast<const ObjectExpression*>(expr);
    if (!object) {
        return;
    }

    // 如果启用了类型推断，尝试使用静态结构体初始化
    if (config_.enable_type_inference) {
        auto object_type = type_engine_.InferExpressionType(expr);

        // 如果推断出了对象结构体类型，使用 mjs::Value 包装 new 创建的对象
        if (object_type && object_type->IsObject()) {
            const std::string& struct_name = object_type->GetStructName();

            // mjs GC 对象创建方式：使用 new 创建，然后用 mjs::Value 包装
            // mjs::Value 会通过引用计数自动管理对象生命周期
            os << "mjs::Value(new " << struct_name << "(context";

            const auto& properties = object->properties();
            for (size_t i = 0; i < properties.size(); ++i) {
                os << ", ";
                GenerateExpression(properties[i].value.get(), os);
            }

            os << "))";
            return;
        }
    }

    // 回退到动态类型：创建空对象，然后逐个设置属性
    // 使用 SetComputedProperty 接受 mjs::Value 作为键
    os << "[&]() { mjs::Value obj = mjs::Value(new mjs::generated::JSObject(context)); ";

    const auto& properties = object->properties();
    for (size_t i = 0; i < properties.size(); ++i) {
        const auto& prop = properties[i];
        // 生成属性设置代码: obj.object().SetComputedProperty(context, key, value);
        // 键需要用 mjs::Value 包装字符串
        os << "obj.object().SetComputedProperty(context, mjs::Value(\"" << prop.key << "\"), ";
        GenerateExpression(prop.value.get(), os);
        os << "); ";
    }

    os << "return obj; }()";
}

void CppCodeGenerator::GenerateStatement(const Statement* stmt, std::ostream& os) {
    if (!stmt) {
        return;
    }

    // 表达式语句
    if (dynamic_cast<const ExpressionStatement*>(stmt)) {
        GenerateExpressionStatement(stmt, os);
        return;
    }

    // 块语句
    if (dynamic_cast<const BlockStatement*>(stmt)) {
        GenerateBlockStatement(stmt, os);
        return;
    }

    // 变量声明
    if (dynamic_cast<const VariableDeclaration*>(stmt)) {
        GenerateVariableDeclaration(stmt, os);
        return;
    }

    // if语句
    if (dynamic_cast<const IfStatement*>(stmt)) {
        GenerateIfStatement(stmt, os);
        return;
    }

    // while语句
    if (dynamic_cast<const WhileStatement*>(stmt)) {
        GenerateWhileStatement(stmt, os);
        return;
    }

    // for语句
    if (dynamic_cast<const ForStatement*>(stmt)) {
        GenerateForStatement(stmt, os);
        return;
    }

    // return语句
    if (dynamic_cast<const ReturnStatement*>(stmt)) {
        GenerateReturnStatement(stmt, os);
        return;
    }

    // TODO: 其他语句类型
    os << "/* unsupported statement type: " << static_cast<int>(stmt->type()) << " */\n";
}

void CppCodeGenerator::GenerateExpressionStatement(const Statement* stmt, std::ostream& os) {
    auto* expr_stmt = dynamic_cast<const ExpressionStatement*>(stmt);
    if (!expr_stmt || !expr_stmt->expression()) {
        return;
    }

    // 检查是否是函数声明（函数表达式作为表达式语句）
    if (auto* func = dynamic_cast<const FunctionExpression*>(expr_stmt->expression().get())) {
        GenerateFunctionDeclaration(func, os);
        return;
    }

    GenerateExpression(expr_stmt->expression().get(), os);
    os << ";\n";
}

void CppCodeGenerator::GenerateBlockStatement(const Statement* stmt, std::ostream& os) {
    auto* block = dynamic_cast<const BlockStatement*>(stmt);
    if (!block) {
        return;
    }

    os << "{\n";
    const auto& statements = block->statements();
    for (const auto& s : statements) {
        // 生成语句到临时流
        std::ostringstream temp_stream;
        GenerateStatement(s.get(), temp_stream);
        std::string stmt_str = temp_stream.str();

        // 对每一行添加缩进
        std::istringstream lines(stmt_str);
        std::string line;
        while (std::getline(lines, line)) {
            if (!line.empty()) {
                os << "    " << line << "\n";
            }
        }
    }
    os << "}\n";
}

void CppCodeGenerator::GenerateVariableDeclaration(const Statement* stmt, std::ostream& os) {
    auto* var_decl = dynamic_cast<const VariableDeclaration*>(stmt);
    if (!var_decl) {
        return;
    }

    const std::string& name = name_mangler_.Mangle(var_decl->name());

    // 推断变量类型
    std::string type_str;
    if (config_.enable_type_inference && var_decl->init()) {
        auto type = type_engine_.InferExpressionType(var_decl->init().get());
        if (type && !type->IsValue()) {
            type_str = type->ToString() + " ";
        }
    }

    // 如果没有类型信息，使用auto
    if (type_str.empty()) {
        type_str = "auto ";
    }

    os << type_str << name;

    // 如果有初始化表达式
    if (var_decl->init()) {
        os << " = ";
        GenerateExpression(var_decl->init().get(), os);
    }

    os << ";\n";
}

void CppCodeGenerator::GenerateIfStatement(const Statement* stmt, std::ostream& os) {
    auto* if_stmt = dynamic_cast<const IfStatement*>(stmt);
    if (!if_stmt) {
        return;
    }

    os << "if (";
    GenerateExpression(if_stmt->test().get(), os);
    os << ") ";

    // 检查 consequent 是否是块语句
    std::ostringstream consequent_stream;
    GenerateStatement(if_stmt->consequent().get(), consequent_stream);
    std::string consequent_str = consequent_stream.str();

    // 如果不是块语句，需要添加缩进
    if (consequent_str.find("{") == 0) {
        // 已经是块语句，直接输出
        os << consequent_str;
    } else {
        // 不是块语句，需要处理缩进
        std::istringstream lines(consequent_str);
        std::string line;
        bool first = true;
        while (std::getline(lines, line)) {
            if (!line.empty()) {
                if (!first) os << "    ";
                os << line << "\n";
                first = false;
            }
        }
    }

    if (if_stmt->alternate()) {
        os << "else ";

        std::ostringstream alternate_stream;
        GenerateStatement(if_stmt->alternate().get(), alternate_stream);
        std::string alternate_str = alternate_stream.str();

        // 如果不是块语句，需要添加缩进
        if (alternate_str.find("{") == 0) {
            os << alternate_str;
        } else {
            std::istringstream lines(alternate_str);
            std::string line;
            bool first = true;
            while (std::getline(lines, line)) {
                if (!line.empty()) {
                    if (!first) os << "    ";
                    os << line << "\n";
                    first = false;
                }
            }
        }
    }
}

void CppCodeGenerator::GenerateWhileStatement(const Statement* stmt, std::ostream& os) {
    auto* while_stmt = dynamic_cast<const WhileStatement*>(stmt);
    if (!while_stmt) {
        return;
    }

    os << "while (";
    GenerateExpression(while_stmt->test().get(), os);
    os << ") ";

    // 生成body并处理缩进
    std::ostringstream body_stream;
    GenerateStatement(while_stmt->body().get(), body_stream);
    std::string body_str = body_stream.str();

    if (body_str.find("{") == 0) {
        os << body_str;
    } else {
        std::istringstream lines(body_str);
        std::string line;
        bool first = true;
        while (std::getline(lines, line)) {
            if (!line.empty()) {
                if (!first) os << "    ";
                os << line << "\n";
                first = false;
            }
        }
    }
}

void CppCodeGenerator::GenerateForStatement(const Statement* stmt, std::ostream& os) {
    auto* for_stmt = dynamic_cast<const ForStatement*>(stmt);
    if (!for_stmt) {
        return;
    }

    os << "for (";

    // init部分
    if (for_stmt->init()) {
        // 对于for循环的init，我们需要移除末尾的分号和换行
        std::ostringstream init_stream;
        GenerateStatement(for_stmt->init().get(), init_stream);
        std::string init_str = init_stream.str();
        // 移除末尾的";\n"替换为"; "
        size_t semicolon_pos = init_str.find_last_of(';');
        if (semicolon_pos != std::string::npos) {
            init_str = init_str.substr(0, semicolon_pos + 1) + " ";
        }
        os << init_str;
    } else {
        os << "; ";
    }

    // test部分
    if (for_stmt->test()) {
        GenerateExpression(for_stmt->test().get(), os);
    }
    os << "; ";

    // update部分
    if (for_stmt->update()) {
        GenerateExpression(for_stmt->update().get(), os);
    }

    os << ") ";

    // 生成body并处理缩进
    std::ostringstream body_stream;
    GenerateStatement(for_stmt->body().get(), body_stream);
    std::string body_str = body_stream.str();

    if (body_str.find("{") == 0) {
        os << body_str;
    } else {
        std::istringstream lines(body_str);
        std::string line;
        bool first = true;
        while (std::getline(lines, line)) {
            if (!line.empty()) {
                if (!first) os << "    ";
                os << line << "\n";
                first = false;
            }
        }
    }
}

void CppCodeGenerator::GenerateReturnStatement(const Statement* stmt, std::ostream& os) {
    auto* ret_stmt = dynamic_cast<const ReturnStatement*>(stmt);
    if (!ret_stmt) {
        return;
    }

    os << "return";

    if (ret_stmt->argument()) {
        os << " ";
        GenerateExpression(ret_stmt->argument().get(), os);
    }

    os << ";\n";
}

void CppCodeGenerator::GenerateFunctionDeclaration(const FunctionExpression* func, std::ostream& os) {
    if (!func) {
        return;
    }

    // 推断函数签名
    FunctionSignature sig;
    if (config_.enable_type_inference) {
        sig = type_engine_.InferFunctionSignature(func);
    }

    // 生成返回值类型
    if (sig.return_type && !sig.return_type->IsValue()) {
        os << sig.return_type->ToString() << " ";
    } else {
        os << "auto ";
    }

    // 生成函数名（如果是匿名函数，使用lambda）
    if (func->id().empty()) {
        // 匿名函数，使用lambda表达式
        os << "[&](";
    } else {
        os << name_mangler_.Mangle(func->id()) << "(";
    }

    // 生成参数列表
    const auto& params = func->params();
    for (size_t i = 0; i < params.size(); ++i) {
        if (i > 0) os << ", ";

        // 参数类型
        if (config_.enable_type_inference && i < sig.param_types.size()) {
            auto& param_type = sig.param_types[i];
            if (param_type->IsValue()) {
                // 动态类型使用auto（C++20支持函数模板参数）
                os << "auto ";
            } else {
                os << param_type->ToString() << " ";
            }
        } else {
            // 默认使用auto作为参数类型
            os << "auto ";
        }

        os << name_mangler_.Mangle(params[i]);
    }

    os << ") ";

    // 生成函数体
    if (func->body()) {
        // 进入函数作用域
        type_engine_.EnterScope();

        // 将参数类型添加到作用域
        if (config_.enable_type_inference) {
            for (size_t i = 0; i < params.size() && i < sig.param_types.size(); ++i) {
                type_engine_.SetVariableType(params[i], sig.param_types[i]);
            }
        }

        // 生成函数体
        GenerateStatement(func->body().get(), os);

        // 离开函数作用域
        type_engine_.ExitScope();
    } else {
        os << "{}\n";
    }

    // 如果是命名函数，添加换行
    if (!func->id().empty()) {
        os << "\n";
    }
}

void CppCodeGenerator::GenerateFunctionSignature(const std::string& name,
                                                const std::vector<std::string>& params,
                                                std::ostream& os) {
    // TODO: 生成带类型的函数签名
    os << "auto " << name_mangler_.Mangle(name) << "(";
    for (size_t i = 0; i < params.size(); ++i) {
        if (i > 0) os << ", ";
        os << "auto " << name_mangler_.Mangle(params[i]);
    }
    os << ")";
}

std::string CppCodeGenerator::GetTypeAnnotation(const Expression* expr) {
    if (!config_.enable_type_inference) {
        return "";
    }

    auto type = type_engine_.InferExpressionType(expr);
    if (type && !type->IsValue()) {
        return " /* " + type->ToString() + " */";
    }
    return "";
}

} // namespace cpp_gen
} // namespace compiler
} // namespace mjs
