#include <mjs/context.h>

#include <iostream>
#include <string_view>

#include <mjs/runtime.h>
#include <mjs/object_impl/module_object.h>

#include "compiler/lexer.h"
#include "compiler/parser.h"
#include "compiler/codegener.h"

namespace mjs {

Value Context::Compile(std::string module_name, std::string_view script) {
	auto lexer = compiler::Lexer(script.data());

	auto parser = compiler::Parser(&lexer);
	parser.ParseProgram();

	auto codegener = compiler::CodeGener(runtime_, &parser);
	auto module = codegener.Generate(std::move(module_name));

	vm_.ModuleInit(&module);

	return module;
}

Value Context::CallModule(Value* value) {
	std::initializer_list<Value> argv = {};
	return CallFunction(value, Value(), argv.begin(), argv.end());
}


Value Context::Eval(std::string module_name, std::string_view script) {
	auto module = Compile(std::move(module_name), script);
	CallModule(&module);
	return module;
}

Value Context::EvalByPath(std::string_view path) {
	auto module = runtime_->module_mgr().GetModule(this, path);
	return module;
}

ConstIndex Context::InsertConst(const Value& value) {
	if (value.const_index() != kConstIndexInvalid) {
		return value.const_index();
	}

	//这里需要保证的是，当前Context运行下，不会出现相等的Value，出现不同的const_index

	// 先查Local，再查Global，最后插入Local，可以保证要么从当前时间开始，使用的都是Global的，要么使用的都是Local的
	// 即使未来Global被插入了相同的Value，也不会使用Global的Value

	auto local_res = local_const_pool_.find(value);
	if (local_res) {
		return *local_res;
	}

	auto global_res = runtime_->const_pool().find(value);
	if (global_res) {
		return *global_res;
	}

	return local_const_pool_.insert(value);
}

} // namespace mjs